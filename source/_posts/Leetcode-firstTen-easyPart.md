---
title: Leetcode-firstTen-easyPart
date: 2020-02-18 11:06:14
tags:
    - 自学
    - 笔记
categories: 
    - Leetcode
    - firstTen
    - easyPart
---
<!-- TOC -->

- [1. Q1：](#1-q1)
- [2. Q7：](#2-q7)
- [3. Q9：](#3-q9)
- [4. Q13：](#4-q13)
- [5. Q14：](#5-q14)
- [6. Q20：](#6-q20)
- [7. Q21：](#7-q21)
- [8. Q26：](#8-q26)
- [9. Q27：](#9-q27)
- [10. Q28(kmp)：](#10-q28kmp)

<!-- /TOC -->
# 1. Q1：
```
 给定一个整数数组 nums 和一个目标值 target，请你在该数组中
 找出和为目标值的那 两个 整数，并返回他们的数组下标。

 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

 示例:

  给定 nums = [2, 7, 11, 15], target = 9
  因为 nums[0] + nums[1] = 2 + 7 = 9
  所以返回 [0, 1]
```
review ideas：
* **暴力法：** 拿到一个数就把数组遍历一遍 

    时间复杂度:O(n^2) 空间复杂度:O(1)
* **Hashmap：** 存储key（ 能被查询的）value  index (利用两个互相匹配的idea 可以一次循环 不需要先存在查)

    时间复杂度：O(n) 空间复杂度:O(n)

# 2. Q7：
```
>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

示例 1:
输入: 123
输出: 321

 示例 2:
输入: -123
输出: -321

示例 3:
输入: 120
输出: 21

**注意:**
假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。
```

review ideas: 
* **String法：** 利用reverse

    时间复杂度：O(n) 空间复杂度:O(n)
* **取余法：** 取余得个位 除10在取余得十位 需要注意判断 最大值、最小值条件  
    时间复杂度：O(n) 空间复杂度:O(1)

# 3. Q9：
```
>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
示例 1:
输入: 121
输出: true

示例 2:
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

示例 3:
输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。

**进阶:**
你能不将整数转为字符串来解决这个问题吗？

```
review ideas：
* **String法：** 利用reverse

    时间复杂度：O(n) 空间复杂度:O(n)
* **取余法：** 取余得个位 除10在取余得十位 (只需一半回文即可，遍历到反转的比正常的大)

    时间复杂度：O(n/2) 空间复杂度:O(1)

# 4. Q13：

```
罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。
这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
示例 1:
输入: "III"
输出: 3

示例 2:
输入: "IV"
输出: 4

示例 3:
输入: "IX"
输出: 9

示例 4:
输入: "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.

示例 5:
输入: "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```


review ideas：
* **暴力法**： 找到'I' 'X' 'C' 然后匹配左边计算 （程序比较乱)

    时间复杂度：O(n) 空间复杂度:O(1)
* **list表 加value数组** ： 通过index判断左右 通过value计算

    时间复杂度：O(n) 空间复杂度:O(1)
* **双指针：switch得到值 pre_num和当前比较 （罗马字的特点只要之前是小的就一定减) 根据大小加减**

    时间复杂度：O(n) 空间复杂度:O(1)

# 5. Q14：
```
编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 ""。

示例 1:
输入: ["flower","flow","flight"]
输出: "fl"

示例 2:
输入: ["dog","racecar","car"]
输出: ""

解释: 输入不存在公共前缀。

说明:
所有输入只包含小写字母 a-z 。
```
review ideas：
* **暴力法**： 找到最小串。从他开始遍历 

    时间复杂度：O(nm) 空间复杂度:O(m)
* **迭代法** ： 找两个前缀 继续迭代

    时间复杂度：O(nm) 空间复杂度:O(m)
* **暴力法2**：从第一个串的第一个字符开始 直到每个子串没了 或者不匹配利用indexof查找字符串的最后位置（short and beauty)

    时间复杂度：O(nm) 空间复杂度:O(m)


# 6. Q20：
```
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

示例 1:

输入: "()"
输出: true
示例 2:

输入: "()[]{}"
输出: true
示例 3:

输入: "(]"
输出: false
示例 4:

输入: "([)]"
输出: false
示例 5:

输入: "{[]}"
输出: true
```
review ideas：
* **栈**： 注意边界问题(可以把匹配的存进Hashmap)

    时间复杂度：O(n) 空间复杂度:O(n)


# 7. Q21：
```

将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4



```
review ideas：
**注意 链表的空间已经有了 尽量在没申请其他空间的情况下链接他们，而不是复制**

**递归法**：递归合并 遍历到空 

    时间复杂度：O(2n) 空间复杂度:O(n)
**迭代法**: 迭代（与上面一样的思路) (要注意保存链表头)

    时间复杂度：O(2n) 空间复杂度:O(n)

# 8. Q26：
```

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

示例 1:

给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
示例 2:

给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。

```



review ideas：


* **双指针**：记录当前位置和遍历 位置

    时间复杂度：O(n) 空间复杂度:O(1)


# 9. Q27：
```

给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1:

给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。
示例 2:

给定 nums = [0,1,2,2,3,0,4,2], val = 2,

函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素


```



review ideas：


* **双指针**：记录当前位置和遍历 位置

    时间复杂度：O(n) 空间复杂度:O(1)

# 10. Q28(kmp)：
```

实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1:

输入: haystack = "hello", needle = "ll"
输出: 2
示例 2:

输入: haystack = "aaaaa", needle = "bba"
输出: -1
说明:

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。


```



review ideas：


* **匹配第一个字符子串法**：正常想法

    时间复杂度：O(nm) 空间复杂度:O(1)


* **KMP(查找效率高，状态机)**：**状态机来节省时间 当大型数据时候特别有效**

    时间复杂度：O(n) 空间复杂度:O(m)（二维数组时空复杂度O(m))