---
title: Leetcode-secondTen-easyPart
date: 2020-02-25 09:42:34
tags:
    - 自学
    - 笔记
categories: 
    - Leetcode
    - secondTen
    - easyPart
---<!-- TOC -->

- [1. Q35](#1-q35)
- [2. Q38](#2-q38)
- [3. Q53](#3-q53)
- [4. Q58](#4-q58)
- [5. Q66](#5-q66)
- [6. Q67](#6-q67)
- [7. Q69](#7-q69)
- [8. Q70](#8-q70)
- [9. Q83](#9-q83)
- [10. Q88](#10-q88)

<!-- /TOC -->

# 1. Q35
```
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

示例 1:

输入: [1,3,5,6], 5
输出: 2
示例 2:

输入: [1,3,5,6], 2
输出: 1
示例 3:

输入: [1,3,5,6], 7
输出: 4
示例 4:

输入: [1,3,5,6], 0
输出: 0
```
review ideas：
* **暴力法：** 直接遍历

    时间复杂度:O(n) 空间复杂度:O(1)

* **折半查找：** 注意细节 (left+right)<<<1 无符号右移 不怕溢出。 
    * 第一种方法折半 left<=right 注意防止死循环 可以利用right=mid-1 left=mid+1 return left
    * 第二种方法折半 left<right 分成两个区间[0,mid][mid+1,right] 然后提前判断最前面和最后面的位置防止死循环和错解。

    时间复杂度：O(log2 N) 空间复杂度:O(1)


# 2. Q38
```
「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：

1.     1
2.     11
3.     21
4.     1211
5.     111221
1 被读作  "one 1"  ("一个一") , 即 11。
11 被读作 "two 1s" ("两个一"）, 即 21。
21 被读作 "one 2",  "one 1" （"一个二" ,  "一个一") , 即 1211。

给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。

注意：整数序列中的每一项将表示为一个字符串。


示例 1:

输入: 1
输出: "1"
解释：这是一个基本样例。
示例 2:

输入: 4
输出: "1211"
解释：当 n = 3 时，序列是 "21"，其中我们有 "2" 和 "1" 两组，"2" 可以读作 "12"，也就是出现频次 = 1 而 值 = 2；类似 "1" 可以读作 "11"。所以答案是 "12" 和 "11" 组合在一起，也就是 "1211"。
```
review ideas：
* **暴力法：** 迭代n轮 利用stringbuild.append 添加频率和值

    时间复杂度:O(n) 空间复杂度:O(1)


# 3. Q53
```
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。


```
review ideas：
* **暴力法：** 记录当前时刻的最大值 以及 所有时刻的最大值注意用math.max

    时间复杂度:O(n) 空间复杂度:O(1)

* **分治法：** 每一小块的最大值 

    时间复杂度：O(N*log2 N) 空间复杂度:O(N)

# 4. Q58
```
给定一个仅包含大小写字母和空格 ' ' 的字符串 s，返回其最后一个单词的长度。

如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。

如果不存在最后一个单词，请返回 0 。

说明：一个单词是指仅由字母组成、不包含任何空格的 最大子字符串。

 

示例:

输入: "Hello World"
输出: 5

```
review ideas：
* **反向遍历法(暴力法)：** 遍历到' '通过substring()位置取出子串 （末尾的空格不算

    时间复杂度:O(n) 空间复杂度:O(1)


# 5. Q66
```
给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1:

输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
示例 2:

输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。

```
review ideas：
* **暴力法：** 根据十进制 从末位开始相加 %10 carry  加到最后在申请空间

    时间复杂度:O(n) 空间复杂度:O(1)

# 6. Q67
```
给定两个二进制字符串，返回他们的和（用二进制表示）。

输入为非空字符串且只包含数字 1 和 0。

示例 1:

输入: a = "11", b = "1"
输出: "100"
示例 2:

输入: a = "1010", b = "1011"
输出: "10101"


```
review ideas：
* **函数法：** 转换成int 然后加法 然后在转换回去（有溢出)
可以利用biginteger去掉溢出 但是效率很慢

    时间复杂度:O(n+m)) 空间复杂度:O(max(n,m))

* **暴力法：** 遍历常的一串 利用return 的方式选取长度大的在a 小的在b 然后遍历短的在遍历长的 思路清晰 需要注意可以利用stringbuild(性能最好) append reverse 

    时间复杂度:O(max(n,m)) 空间复杂度:O(max(n,m))

* **移位法：** 在不允许加法的情况下 利用a|b+ carry(a&b<<1)
反复得到

    时间复杂度:O(max(n,m)) 空间复杂度:O(max(n,m))

# 7. Q69
```
实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例 1:

输入: 4
输出: 2
示例 2:

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。



```
review ideas：
* **公式法：** e^0.5lnx

    时间复杂度:O(1) 空间复杂度:O(1)

* **牛顿法：** 迭代n轮

    时间复杂度:O(log2n) 空间复杂度:O(1)


# 8. Q70
```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```
review ideas：
* **递归法：** 爬一步爬两步 

    时间复杂度:O(2^n) 空间复杂度:O(N) （**树的深度**）

* **动态规划DP：** 当前等于前面两步的之和

    时间复杂度:O(N) 空间复杂度:O(N)

* **数列法（规律）：** 当前等于前面两步的之和

    时间复杂度:O(N) 空间复杂度:O(1)

* **Binets 方法：** 利用矩阵计算斐波那数列

    时间复杂度:O(logn) 空间复杂度:O(1)

# 9. Q83
```
给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

示例 1:

输入: 1->1->2
输出: 1->2
示例 2:

输入: 1->1->2->3->3
输出: 1->2->3

```
review ideas：
* **双指针：** 记录当前的和已遍历

    时间复杂度:O(n) 空间复杂度:O(1)

# 10. Q88
```

给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。

说明:

初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
示例:

输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]

```
review ideas：
* **双指针：** 需要创建的新的空间（system.arraycopy 可以复制空间)

    时间复杂度:O(n) 空间复杂度:O(n)

* **双指针（从后遍历）：** 从后面遍历这样不需要新的空间

    时间复杂度:O(n) 空间复杂度:O(1)
